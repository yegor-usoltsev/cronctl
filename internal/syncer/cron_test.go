package syncer

import (
	"strings"
	"testing"

	"github.com/yegor-usoltsev/cronctl/internal/job"
)

func TestRenderCron(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name       string
		job        job.Job
		targetPath string
		want       string
		wantErr    bool
	}{
		{
			name: "basic job with one schedule",
			job: job.Job{
				ID: "test-job",
				Spec: job.Spec{
					User: "testuser",
					Env: map[string]string{
						"PATH": "/usr/bin:/bin",
					},
					Run: job.RunSpec{
						Entrypoint: "run.sh",
					},
					Schedule: []job.ScheduleItem{
						{
							Cron: "0 * * * *",
							Args: []string{},
							Env:  map[string]string{},
						},
					},
				},
			},
			targetPath: "/opt/cronctl/jobs/test-job",
			want: `# Generated by cronctl. DO NOT EDIT.
PATH=/usr/bin:/bin
0 * * * * testuser '/opt/cronctl/jobs/test-job/run.sh'
`,
		},
		{
			name: "job with args and schedule env",
			job: job.Job{
				ID: "test-job",
				Spec: job.Spec{
					User: "root",
					Env: map[string]string{
						"MAILTO": "admin@example.com",
					},
					Run: job.RunSpec{
						Entrypoint: "script.sh",
					},
					Schedule: []job.ScheduleItem{
						{
							Cron: "*/5 * * * *",
							Args: []string{"arg1", "arg with spaces"},
							Env: map[string]string{
								"FOO": "bar",
								"BAZ": "qux",
							},
						},
					},
				},
			},
			targetPath: "/opt/jobs/test-job",
			want: `# Generated by cronctl. DO NOT EDIT.
MAILTO=admin@example.com
*/5 * * * * root BAZ='qux' FOO='bar' '/opt/jobs/test-job/script.sh' 'arg1' 'arg with spaces'
`,
		},
		{
			name: "job with silent schedule",
			job: job.Job{
				ID: "test-job",
				Spec: job.Spec{
					User: "nobody",
					Env:  map[string]string{},
					Run: job.RunSpec{
						Entrypoint: "worker.sh",
					},
					Schedule: []job.ScheduleItem{
						{
							Cron:   "0 0 * * *",
							Args:   []string{},
							Env:    map[string]string{},
							Silent: true,
						},
					},
				},
			},
			targetPath: "/opt/cronctl/jobs/test-job",
			want: `# Generated by cronctl. DO NOT EDIT.
0 0 * * * nobody '/opt/cronctl/jobs/test-job/worker.sh' >/dev/null 2>&1
`,
		},
		{
			name: "multiple schedules with mixed silent",
			job: job.Job{
				ID: "multi",
				Spec: job.Spec{
					User: "app",
					Env: map[string]string{
						"PATH": "/usr/local/bin:/usr/bin",
					},
					Run: job.RunSpec{
						Entrypoint: "run.sh",
					},
					Schedule: []job.ScheduleItem{
						{
							Cron:   "*/10 * * * *",
							Args:   []string{"check"},
							Env:    map[string]string{},
							Silent: false,
						},
						{
							Cron:   "0 */6 * * *",
							Args:   []string{"cleanup"},
							Env:    map[string]string{},
							Silent: true,
						},
					},
				},
			},
			targetPath: "/opt/cronctl/jobs/multi",
			want: `# Generated by cronctl. DO NOT EDIT.
PATH=/usr/local/bin:/usr/bin
*/10 * * * * app '/opt/cronctl/jobs/multi/run.sh' 'check'
0 */6 * * * app '/opt/cronctl/jobs/multi/run.sh' 'cleanup' >/dev/null 2>&1
`,
		},
		{
			name: "empty user",
			job: job.Job{
				ID: "bad-job",
				Spec: job.Spec{
					User: "",
					Env:  map[string]string{},
					Run: job.RunSpec{
						Entrypoint: "run.sh",
					},
					Schedule: []job.ScheduleItem{
						{Cron: "0 * * * *"},
					},
				},
			},
			targetPath: "/opt/cronctl/jobs/bad-job",
			wantErr:    true,
		},
		{
			name: "empty cron expression",
			job: job.Job{
				ID: "bad-cron",
				Spec: job.Spec{
					User: "root",
					Env:  map[string]string{},
					Run: job.RunSpec{
						Entrypoint: "run.sh",
					},
					Schedule: []job.ScheduleItem{
						{Cron: ""},
					},
				},
			},
			targetPath: "/opt/cronctl/jobs/bad-cron",
			wantErr:    true,
		},
		{
			name: "invalid env key",
			job: job.Job{
				ID: "bad-env",
				Spec: job.Spec{
					User: "root",
					Env:  map[string]string{},
					Run: job.RunSpec{
						Entrypoint: "run.sh",
					},
					Schedule: []job.ScheduleItem{
						{
							Cron: "0 * * * *",
							Env: map[string]string{
								"INVALID-KEY": "value",
							},
						},
					},
				},
			},
			targetPath: "/opt/cronctl/jobs/bad-env",
			wantErr:    true,
		},
		{
			name: "shell escaping with quotes",
			job: job.Job{
				ID: "escape-test",
				Spec: job.Spec{
					User: "root",
					Env:  map[string]string{},
					Run: job.RunSpec{
						Entrypoint: "run.sh",
					},
					Schedule: []job.ScheduleItem{
						{
							Cron: "0 * * * *",
							Args: []string{"it's", `"quoted"`, "$VAR"},
							Env: map[string]string{
								"VAL": "has'quote",
							},
						},
					},
				},
			},
			targetPath: "/opt/cronctl/jobs/escape-test",
			want: `# Generated by cronctl. DO NOT EDIT.
0 * * * * root VAL='has'\''quote' '/opt/cronctl/jobs/escape-test/run.sh' 'it'\''s' '"quoted"' '$VAR'
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			got, err := renderCron(tt.job, tt.targetPath)
			if (err != nil) != tt.wantErr {
				t.Errorf("renderCron() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err != nil {
				return
			}
			if string(got) != tt.want {
				t.Errorf("renderCron() =\n%s\nwant:\n%s", string(got), tt.want)
			}
		})
	}
}

func TestShellEscape(t *testing.T) {
	t.Parallel()
	tests := []struct {
		input string
		want  string
	}{
		{"", "''"},
		{"simple", "'simple'"},
		{"with spaces", "'with spaces'"},
		{"it's", "'it'\\''s'"},
		{"multiple'quotes'here", "'multiple'\\''quotes'\\''here'"},
		{"$VAR", "'$VAR'"},
		{`"quoted"`, `'"quoted"'`},
		{"\n\t", "'\n\t'"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			t.Parallel()
			got := shellEscape(tt.input)
			if got != tt.want {
				t.Errorf("shellEscape(%q) = %q, want %q", tt.input, got, tt.want)
			}
		})
	}
}

func TestRenderEnvAssignments(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name    string
		env     map[string]string
		want    string
		wantErr bool
	}{
		{
			name: "empty env",
			env:  map[string]string{},
			want: "",
		},
		{
			name: "single var",
			env:  map[string]string{"FOO": "bar"},
			want: "FOO='bar' ",
		},
		{
			name: "multiple vars sorted",
			env: map[string]string{
				"ZZZ": "last",
				"AAA": "first",
				"MMM": "middle",
			},
			want: "AAA='first' MMM='middle' ZZZ='last' ",
		},
		{
			name:    "invalid key with dash",
			env:     map[string]string{"INVALID-KEY": "value"},
			wantErr: true,
		},
		{
			name:    "invalid key starting with digit",
			env:     map[string]string{"1INVALID": "value"},
			wantErr: true,
		},
		{
			name: "valid key with underscore",
			env:  map[string]string{"VALID_KEY": "value"},
			want: "VALID_KEY='value' ",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			got, err := renderEnvAssignments(tt.env)
			if (err != nil) != tt.wantErr {
				t.Errorf("renderEnvAssignments() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err != nil {
				return
			}
			if got != tt.want {
				t.Errorf("renderEnvAssignments() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestRenderCronNoSchedule(t *testing.T) {
	t.Parallel()
	j := job.Job{
		ID: "no-schedule",
		Spec: job.Spec{
			User: "root",
			Env: map[string]string{
				"PATH": "/usr/bin",
			},
			Run: job.RunSpec{
				Entrypoint: "run.sh",
			},
			Schedule: []job.ScheduleItem{},
		},
	}

	got, err := renderCron(j, "/opt/cronctl/jobs/no-schedule")
	if err != nil {
		t.Fatalf("renderCron() unexpected error: %v", err)
	}

	want := `# Generated by cronctl. DO NOT EDIT.
PATH=/usr/bin
`
	if string(got) != want {
		t.Errorf("renderCron() with no schedule =\n%s\nwant:\n%s", string(got), want)
	}
}

func TestRenderCronSortedGlobalEnv(t *testing.T) {
	t.Parallel()
	j := job.Job{
		ID: "sorted-env",
		Spec: job.Spec{
			User: "root",
			Env: map[string]string{
				"ZZZ":    "last",
				"AAA":    "first",
				"MAILTO": "admin@example.com",
			},
			Run: job.RunSpec{
				Entrypoint: "run.sh",
			},
			Schedule: []job.ScheduleItem{
				{Cron: "0 * * * *"},
			},
		},
	}

	got, err := renderCron(j, "/opt/cronctl/jobs/sorted-env")
	if err != nil {
		t.Fatalf("renderCron() unexpected error: %v", err)
	}

	lines := strings.Split(string(got), "\n")
	if len(lines) < 4 {
		t.Fatalf("expected at least 4 lines, got %d", len(lines))
	}

	// Check that env vars are sorted
	if lines[1] != "AAA=first" {
		t.Errorf("line 1: got %q, want %q", lines[1], "AAA=first")
	}
	if lines[2] != "MAILTO=admin@example.com" {
		t.Errorf("line 2: got %q, want %q", lines[2], "MAILTO=admin@example.com")
	}
	if lines[3] != "ZZZ=last" {
		t.Errorf("line 3: got %q, want %q", lines[3], "ZZZ=last")
	}
}
