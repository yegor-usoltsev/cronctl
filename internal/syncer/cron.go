package syncer

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/yegor-usoltsev/cronctl/internal/job"
)

var envKeyRe = regexp.MustCompile(`^[A-Za-z_][A-Za-z0-9_]*$`)

func writeCronFile(dryRun bool, cronPath string, j job.Job, targetPath string) error {
	data, err := renderCron(j, targetPath)
	if err != nil {
		return err
	}
	if dryRun {
		log.Printf("dry-run: write cron %s", cronPath)
		return nil
	}
	if err := os.MkdirAll(filepath.Dir(cronPath), 0o755); err != nil {
		return fmt.Errorf("mkdir cron dir: %w", err)
	}
	if err := writeFileAtomic(cronPath, 0o644, data); err != nil {
		return err
	}
	if err := os.Chown(cronPath, 0, 0); err != nil {
		return fmt.Errorf("chown cron file: %w", err)
	}
	return nil
}

func renderCron(j job.Job, targetPath string) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("# Generated by cronctl. DO NOT EDIT.\n")

	keys := make([]string, 0, len(j.Spec.Env))
	for k := range j.Spec.Env {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		if !envKeyRe.MatchString(k) {
			return nil, fmt.Errorf("%w: %q", errInvalidEnvKey, k)
		}
		// Global env vars in cron files are written as: KEY=value (no shell escaping needed)
		buf.WriteString(fmt.Sprintf("%s=%s\n", k, j.Spec.Env[k]))
	}

	user := strings.TrimSpace(j.Spec.User)
	if user == "" {
		return nil, errUserEmpty
	}

	runEntrypoint := strings.TrimSpace(j.Spec.Run.Entrypoint)
	if runEntrypoint == "" {
		runEntrypoint = job.DefaultRunEntrypoint
	}
	cmdPath := filepath.Join(targetPath, runEntrypoint)

	for i, s := range j.Spec.Schedule {
		cron := strings.TrimSpace(s.Cron)
		if cron == "" {
			return nil, fmt.Errorf("schedule[%d]: %w", i, errScheduleCronEmpty)
		}
		// Schedule-specific env vars (merged on top of global_env at runtime by cron)
		prefix, err := renderEnvAssignments(s.Env)
		if err != nil {
			return nil, fmt.Errorf("schedule[%d]: %w", i, err)
		}

		args := s.Args
		var argStr string
		if len(args) > 0 {
			parts := make([]string, 0, len(args))
			for _, a := range args {
				parts = append(parts, shellEscape(a))
			}
			argStr = " " + strings.Join(parts, " ")
		}

		var redirect string
		if s.Silent {
			redirect = " >/dev/null 2>&1"
		}

		line := fmt.Sprintf("%s %s %s%s%s%s\n", cron, user, prefix, shellEscape(cmdPath), argStr, redirect)
		buf.WriteString(line)
	}

	return buf.Bytes(), nil
}

func renderEnvAssignments(env map[string]string) (string, error) {
	if len(env) == 0 {
		return "", nil
	}
	keys := make([]string, 0, len(env))
	for k := range env {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	parts := make([]string, 0, len(keys))
	for _, k := range keys {
		if !envKeyRe.MatchString(k) {
			return "", fmt.Errorf("%w: %q", errInvalidEnvKey, k)
		}
		parts = append(parts, fmt.Sprintf("%s=%s", k, shellEscape(env[k])))
	}
	return strings.Join(parts, " ") + " ", nil
}

func shellEscape(s string) string {
	// POSIX shell safe quoting using single quotes.
	if s == "" {
		return "''"
	}
	if !strings.ContainsRune(s, '\'') {
		return "'" + s + "'"
	}
	// close-quote, escaped quote, reopen
	return "'" + strings.ReplaceAll(s, "'", "'\\''") + "'"
}
